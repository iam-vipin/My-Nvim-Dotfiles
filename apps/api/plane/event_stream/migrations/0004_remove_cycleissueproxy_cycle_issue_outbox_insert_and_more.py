# Generated by Django 4.2.27 on 2026-01-15 11:42

from django.db import migrations
import pgtrigger.compiler
import pgtrigger.migrations


class Migration(migrations.Migration):

    dependencies = [
        ('event_stream', '0003_remove_issueassigneeproxy_issue_assignee_outbox_insert_and_more'),
    ]

    operations = [
        pgtrigger.migrations.RemoveTrigger(
            model_name='cycleissueproxy',
            name='cycle_issue_outbox_insert',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='cycleissueproxy',
            name='cycle_issue_outbox_update',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issueassigneeproxy',
            name='issue_assignee_outbox_insert',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issueassigneeproxy',
            name='issue_assignee_outbox_update',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issueattachmentproxy',
            name='issue_attachment_outbox_insert',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issueattachmentproxy',
            name='issue_attachment_outbox_update',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issuecommentproxy',
            name='issue_comment_outbox_insert',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issuecommentproxy',
            name='issue_comment_outbox_update',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issuelabelproxy',
            name='issue_label_outbox_insert',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issuelabelproxy',
            name='issue_label_outbox_update',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issuelinkproxy',
            name='issue_link_outbox_insert',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issuelinkproxy',
            name='issue_link_outbox_update',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issueproxy',
            name='issue_outbox_insert',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issueproxy',
            name='issue_outbox_update',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issuerelationproxy',
            name='issue_relation_outbox_insert',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='issuerelationproxy',
            name='issue_relation_outbox_update',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='moduleissueproxy',
            name='module_issue_outbox_insert',
        ),
        pgtrigger.migrations.RemoveTrigger(
            model_name='moduleissueproxy',
            name='module_issue_outbox_update',
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='cycleissueproxy',
            trigger=pgtrigger.compiler.Trigger(name='cycle_issue_outbox_insert', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                BEGIN\n                    BEGIN\n                        -- try to enqueue event; ignore dupes and handle unexpected errors\n                        INSERT INTO outbox (\n                            event_id, event_type, entity_type, entity_id, payload, workspace_id, project_id, created_at, initiator_id, initiator_type\n                        )\n                        VALUES (\n                            gen_random_uuid(),\n                            'workitem.cycle.added',\n                            'cycle_issue',\n                            NEW.issue_id,\n                            jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', '{}'),\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;            -- (optional) skip duplicates\n                    EXCEPTION\n                        WHEN others THEN\n                            -- log but DO NOT re-throw, so the main insert survives\n                            RAISE WARNING 'Outbox insert failed for cycle_issue %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ", hash='0b8781d10126763d806edd162621c97284ad9949', operation='INSERT', pgid='pgtrigger_cycle_issue_outbox_insert_66548', table='cycle_issues', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='cycleissueproxy',
            trigger=pgtrigger.compiler.Trigger(name='cycle_issue_outbox_update', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                BEGIN\n                    BEGIN\n                        -- Check if this is a soft delete (deleted_at changed from null to not null)\n                        IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                            -- This is a soft delete\n                            INSERT INTO outbox (\n                                event_id, event_type, entity_type, entity_id, payload, workspace_id, project_id, created_at, initiator_id, initiator_type\n                            )\n                            VALUES (\n                                gen_random_uuid(),\n                                'workitem.cycle.removed',\n                                'cycle_issue',\n                                OLD.issue_id,\n                                jsonb_build_object('data', '{}', 'previous_attributes', row_to_json(OLD)),\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        ELSE\n                            -- This is a regular update - only trigger if cycle_id changed\n                            IF OLD.cycle_id IS DISTINCT FROM NEW.cycle_id THEN\n                                INSERT INTO outbox (\n                                    event_id, event_type, entity_type, entity_id, payload, workspace_id, project_id, created_at, initiator_id, initiator_type\n                                )\n                                VALUES (\n                                    gen_random_uuid(),\n                                    'workitem.cycle.moved',\n                                    'cycle_issue',\n                                    NEW.issue_id,\n                                    jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', row_to_json(OLD)),\n                                    NEW.workspace_id,\n                                    NEW.project_id,\n                                    now(),\n                                    NEW.updated_by_id,\n                                    COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                )\n                                ON CONFLICT DO NOTHING;\n                            END IF;\n                        END IF;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox update-event failed for cycle_issue %, reason: %',\n                                         COALESCE(NEW.issue_id, OLD.issue_id), SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ", hash='a1f137db129ff5032a0814e1a2163e3c1f4c97e5', operation='UPDATE', pgid='pgtrigger_cycle_issue_outbox_update_38237', table='cycle_issues', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issueassigneeproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_assignee_outbox_insert', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    previous_assignee_ids JSONB;\n                    label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'workitem.assignee.added'\n                            WHEN it.is_epic = true THEN 'epic.assignee.added'\n                            ELSE 'workitem.assignee.added'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'workitem.assignee.added'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'workitem.assignee.added';\n                    END IF;\n                    \n                    -- Get the complete issue data (excluding description fields)\n                    SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                    INTO issue_data\n                    FROM issues i\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- Fetch ALL current assignee IDs (including the newly added one)\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL;\n                    \n                    -- Fetch previous assignee IDs (excluding the newly added one)\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO previous_assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL AND ia.id != NEW.id;\n                    \n                    -- Fetch label IDs\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL;\n                    \n                    -- Create enriched data with complete issue, ALL assignee IDs (including new one), and label IDs\n                    enriched_data := issue_data || jsonb_build_object(\n                            'assignee_ids', assignee_ids,\n                            'label_ids', label_ids\n                    );\n                    \n                    -- Create previous attributes with only the previous assignee IDs\n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue_assignee',\n                            NEW.issue_id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object('data', enriched_data, 'previous_attributes', jsonb_build_object('assignee_ids', previous_assignee_ids)),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue_assignee %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ", hash='bcd0ca09a811828e50b068a5d9021b1aabb5c8eb', operation='INSERT', pgid='pgtrigger_issue_assignee_outbox_insert_51e4c', table='issue_assignees', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issueassigneeproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_assignee_outbox_update', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    current_assignee_ids JSONB;\n                    previous_assignee_ids JSONB;\n                    label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Only trigger on soft delete (deleted_at changing from NULL to NOT NULL)\n                    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                        -- Determine event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'workitem.assignee.removed'\n                                WHEN it.is_epic = true THEN 'epic.assignee.removed'\n                                ELSE 'workitem.assignee.removed'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- If no issue found, default to 'workitem.assignee.removed'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'workitem.assignee.removed';\n                        END IF;\n                        \n                        -- Get the complete issue data (excluding description fields)\n                        SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                        INTO issue_data\n                        FROM issues i\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- Fetch current assignee IDs (excluding the one being removed)\n                        SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                        INTO current_assignee_ids\n                        FROM issue_assignees ia\n                        WHERE ia.issue_id = OLD.issue_id AND ia.deleted_at IS NULL AND ia.id != OLD.id;\n                        \n                        -- Fetch ALL assignee IDs (including the one being removed) for previous_attributes\n                        SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                        INTO previous_assignee_ids\n                        FROM issue_assignees ia\n                        WHERE ia.issue_id = OLD.issue_id AND ia.deleted_at IS NULL;\n                        \n                        -- Fetch label IDs\n                        SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                        INTO label_ids\n                        FROM issue_labels il\n                        WHERE il.issue_id = OLD.issue_id AND il.deleted_at IS NULL;\n                        \n                        -- Create enriched data with complete issue and current assignee IDs (after removal)\n                        enriched_data := issue_data || jsonb_build_object(\n                                'assignee_ids', current_assignee_ids,\n                                'label_ids', label_ids\n                        );\n                        \n                        -- Create previous attributes with only the previous assignee IDs\n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue_assignee',\n                                OLD.issue_id,\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                jsonb_build_object('data', enriched_data, 'previous_attributes', jsonb_build_object('assignee_ids', previous_assignee_ids)),\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox delete-event failed for issue_assignee %, reason: %',\n                                             OLD.issue_id, SQLERRM;\n                        END;\n                    END IF;\n                    RETURN NEW;\n                END;\n                ", hash='a98dad5c517b1ec5b6134ca274d2b12f1f7cd53c', operation='UPDATE', pgid='pgtrigger_issue_assignee_outbox_update_97b55', table='issue_assignees', when='BEFORE')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issueattachmentproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_attachment_outbox_insert', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    event_type_name TEXT;\n                BEGIN\n                    -- Only trigger for ISSUE_ATTACHMENT entity type\n                    IF NEW.entity_type = 'ISSUE_ATTACHMENT' THEN\n                        -- Determine event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'workitem.attachment.added'\n                                WHEN it.is_epic = true THEN 'epic.attachment.added'\n                                ELSE 'workitem.attachment.added'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = NEW.issue_id;\n                        \n                        -- If no issue found, default to 'workitem.attachment.added'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'workitem.attachment.added';\n                        END IF;\n                        \n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue_attachment',\n                                NEW.issue_id,\n                                NEW.workspace_id,\n                                NEW.project_id,\n                                jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', '{}'),\n                                now(),\n                                NEW.created_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox insert failed for issue_attachment %, reason: %',\n                                             NEW.issue_id, SQLERRM;\n                        END;\n                    END IF;\n                    RETURN NEW;\n                END;\n                ", hash='84b7bb0c85699d4d3aede30c34a8ea8220a0ad0d', operation='INSERT', pgid='pgtrigger_issue_attachment_outbox_insert_b1598', table='file_assets', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issueattachmentproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_attachment_outbox_update', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    changes JSONB := '{}';\n                    field_name TEXT;\n                    old_value TEXT;\n                    new_value TEXT;\n                    event_type_name TEXT;\n                BEGIN\n                    -- Only trigger for ISSUE_ATTACHMENT entity type\n                    IF NEW.entity_type = 'ISSUE_ATTACHMENT' OR OLD.entity_type = 'ISSUE_ATTACHMENT' THEN\n                        -- Determine event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'workitem.attachment.updated'\n                                WHEN it.is_epic = true THEN 'epic.attachment.updated'\n                                ELSE 'workitem.attachment.updated'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = NEW.issue_id;\n                        \n                        -- If no issue found, default to 'workitem.attachment.updated'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'workitem.attachment.updated';\n                        END IF;\n                        \n                        -- Check if this is a soft delete (deleted_at changed from null to not null)\n                        IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                            -- This is a soft delete\n                            -- Determine delete event type based on issue type\n                            SELECT \n                                CASE \n                                    WHEN i.type_id IS NULL THEN 'workitem.attachment.removed'\n                                    WHEN it.is_epic = true THEN 'epic.attachment.removed'\n                                    ELSE 'workitem.attachment.removed'\n                                END\n                            INTO event_type_name\n                            FROM issues i\n                            LEFT JOIN issue_types it ON it.id = i.type_id\n                            WHERE i.id = OLD.issue_id;\n                            \n                            -- If no issue found, default to 'workitem.attachment.removed'\n                            IF event_type_name IS NULL THEN\n                                event_type_name := 'workitem.attachment.removed';\n                            END IF;\n                            \n                            BEGIN\n                                INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                VALUES (\n                                    gen_random_uuid(),\n                                    event_type_name,\n                                    'issue_attachment',\n                                    OLD.issue_id,\n                                    OLD.workspace_id,\n                                    OLD.project_id,\n                                    jsonb_build_object('data', '{}', 'previous_attributes', row_to_json(OLD)),\n                                    now(),\n                                    NEW.updated_by_id,\n                                    COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                )\n                                ON CONFLICT DO NOTHING;\n                            EXCEPTION\n                                WHEN others THEN\n                                    RAISE WARNING 'Outbox delete failed for issue_attachment %, reason: %',\n                                                 OLD.issue_id, SQLERRM;\n                            END;\n                        ELSE\n                            -- This is a regular update, check for changes\n                            -- Loop through all columns to detect changes\n                            FOR field_name IN \n                                SELECT column_name \n                                FROM information_schema.columns \n                                WHERE table_name = 'file_assets' \n                                AND table_schema = 'public'\n                                AND column_name != 'updated_at'  -- Skip updated_at column\n                            LOOP\n                                -- Get old and new values as text to avoid JSON conversion issues\n                                EXECUTE format('SELECT ($1).%I::text, ($2).%I::text', field_name, field_name) \n                                INTO old_value, new_value \n                                USING OLD, NEW;\n                                \n                                -- If values are different, add to changes\n                                IF old_value IS DISTINCT FROM new_value THEN\n                                    changes := changes || jsonb_build_object(\n                                        field_name, \n                                        old_value\n                                    );\n                                END IF;\n                            END LOOP;\n                            \n                            -- Only insert if there are actual changes\n                            IF jsonb_typeof(changes) = 'object' AND changes != '{}' THEN\n                                BEGIN\n                                    INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                    VALUES (\n                                        gen_random_uuid(),\n                                        event_type_name, \n                                        'issue_attachment',\n                                        NEW.issue_id,\n                                        NEW.workspace_id,\n                                        NEW.project_id,\n                                        jsonb_build_object(\n                                            'data', row_to_json(NEW),\n                                            'previous_attributes', changes\n                                        ),\n                                        now(),\n                                        NEW.updated_by_id,\n                                        COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                    )\n                                    ON CONFLICT DO NOTHING;\n                                EXCEPTION\n                                    WHEN others THEN\n                                        RAISE WARNING 'Outbox update failed for issue_attachment %, reason: %',\n                                                     NEW.issue_id, SQLERRM;\n                                END;\n                            END IF;\n                        END IF;\n                    END IF;\n                    \n                    RETURN NEW;\n                END;\n                ", hash='675abf3499c04bcb2a21dd1f6d034049fe5391a0', operation='UPDATE', pgid='pgtrigger_issue_attachment_outbox_update_5fc41', table='file_assets', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issuecommentproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_comment_outbox_insert', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'workitem.comment.created'\n                            WHEN it.is_epic = true THEN 'epic.comment.created'\n                            ELSE 'workitem.comment.created'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'workitem.comment.created'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'workitem.comment.created';\n                    END IF;\n                    \n                    -- Get the complete issue data (excluding description fields)\n                    SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                    INTO issue_data\n                    FROM issues i\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- Fetch assignee IDs\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL;\n                    \n                    -- Fetch label IDs\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL;\n                    \n                    -- Create enriched data with complete issue, assignee IDs, and label IDs\n                    enriched_data := issue_data || jsonb_build_object(\n                        'assignee_ids', assignee_ids,\n                        'label_ids', label_ids,\n                        'comment', row_to_json(NEW)\n                    );\n                    \n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue',\n                            NEW.issue_id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object('data', enriched_data, 'previous_attributes', '{}'),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue_comment %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ", hash='efdae455e1bd433457bbdde868740bebe20e702b', operation='INSERT', pgid='pgtrigger_issue_comment_outbox_insert_bdd46', table='issue_comments', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issuecommentproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_comment_outbox_update', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    changes JSONB := '{}';\n                    field_name TEXT;\n                    old_value TEXT;\n                    new_value TEXT;\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Check if this is a soft delete (deleted_at changed from null to not null)\n                    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                        -- This is a soft delete\n                        -- Determine delete event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'workitem.comment.deleted'\n                                WHEN it.is_epic = true THEN 'epic.comment.deleted'\n                                ELSE 'workitem.comment.deleted'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- If no issue found, default to 'workitem.comment.deleted'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'workitem.comment.deleted';\n                        END IF;\n                        \n                        -- Get the complete issue data (excluding description fields)\n                        SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                        INTO issue_data\n                        FROM issues i\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- Fetch assignee IDs\n                        SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                        INTO assignee_ids\n                        FROM issue_assignees ia\n                        WHERE ia.issue_id = OLD.issue_id AND ia.deleted_at IS NULL;\n                        \n                        -- Fetch label IDs\n                        SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                        INTO label_ids\n                        FROM issue_labels il\n                        WHERE il.issue_id = OLD.issue_id AND il.deleted_at IS NULL;\n                        \n                        -- Create enriched data with complete issue, assignee IDs, and label IDs\n                        enriched_data := issue_data || jsonb_build_object(\n                            'assignee_ids', assignee_ids,\n                            'label_ids', label_ids\n                        );\n                        \n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue',\n                                OLD.issue_id,\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                jsonb_build_object('data', enriched_data, 'previous_attributes', row_to_json(OLD)),\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox delete failed for issue_comment %, reason: %',\n                                             OLD.issue_id, SQLERRM;\n                        END;\n                    ELSE\n                        -- This is a regular update, check for changes\n                        -- Determine update event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'workitem.comment.updated'\n                                WHEN it.is_epic = true THEN 'epic.comment.updated'\n                                ELSE 'workitem.comment.updated'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = NEW.issue_id;\n                        \n                        -- If no issue found, default to 'workitem.comment.updated'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'workitem.comment.updated';\n                        END IF;\n                        \n                        -- Loop through all columns to detect changes\n                        FOR field_name IN \n                            SELECT column_name \n                            FROM information_schema.columns \n                            WHERE table_name = 'issue_comments' \n                            AND table_schema = 'public'\n                            AND column_name != 'updated_at'  -- Skip updated_at column\n                        LOOP\n                            -- Get old and new values as text to avoid JSON conversion issues\n                            EXECUTE format('SELECT ($1).%I::text, ($2).%I::text', field_name, field_name) \n                            INTO old_value, new_value \n                            USING OLD, NEW;\n                            \n                            -- If values are different, add to changes\n                            IF old_value IS DISTINCT FROM new_value THEN\n                                changes := changes || jsonb_build_object(\n                                    field_name, \n                                    old_value\n                                );\n                            END IF;\n                        END LOOP;\n                        \n                        -- Only insert if there are actual changes\n                        IF jsonb_typeof(changes) = 'object' AND changes != '{}' THEN\n                            -- Get the complete issue data (excluding description fields)\n                            SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                            INTO issue_data\n                            FROM issues i\n                            WHERE i.id = NEW.issue_id;\n                            \n                            -- Fetch assignee IDs\n                            SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                            INTO assignee_ids\n                            FROM issue_assignees ia\n                            WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL;\n                            \n                            -- Fetch label IDs\n                            SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                            INTO label_ids\n                            FROM issue_labels il\n                            WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL;\n                            \n                            -- Create enriched data with complete issue, assignee IDs, label IDs, and updated comment\n                            enriched_data := issue_data || jsonb_build_object(\n                                'assignee_ids', assignee_ids,\n                                'label_ids', label_ids,\n                                'comment', row_to_json(NEW)\n                            );\n                            \n                            BEGIN\n                                INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                VALUES (\n                                    gen_random_uuid(),\n                                    event_type_name, \n                                    'issue',\n                                    NEW.issue_id,\n                                    NEW.workspace_id,\n                                    NEW.project_id,\n                                    jsonb_build_object(\n                                        'data', enriched_data,\n                                        'previous_attributes', changes\n                                    ),\n                                    now(),\n                                    NEW.updated_by_id,\n                                    COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                )\n                                ON CONFLICT DO NOTHING;\n                            EXCEPTION\n                                WHEN others THEN\n                                    RAISE WARNING 'Outbox update failed for issue_comment %, reason: %',\n                                                 NEW.issue_id, SQLERRM;\n                            END;\n                        END IF;\n                    END IF;\n                    \n                    RETURN NEW;\n                END;\n                ", hash='ffaabe4f026002d25c1f523ef0cefda75a56e5bc', operation='UPDATE', pgid='pgtrigger_issue_comment_outbox_update_dc7b2', table='issue_comments', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issuelabelproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_label_outbox_insert', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    label_ids JSONB;\n                    previous_label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'workitem.label.added'\n                            WHEN it.is_epic = true THEN 'epic.label.added'\n                            ELSE 'workitem.label.added'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'workitem.label.added'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'workitem.label.added';\n                    END IF;\n                    \n                    -- Get the complete issue data (excluding description fields)\n                    SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                    INTO issue_data\n                    FROM issues i\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- Fetch assignee IDs\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.issue_id AND ia.deleted_at IS NULL;\n                    \n                    -- Fetch ALL current label IDs (including the newly added one)\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL;\n                    \n                    -- Fetch previous label IDs (excluding the newly added one)\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO previous_label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.issue_id AND il.deleted_at IS NULL AND il.id != NEW.id;\n                    \n                    -- Create enriched data with complete issue, assignee IDs, and ALL label IDs (including new one)\n                    enriched_data := issue_data || jsonb_build_object(\n                            'assignee_ids', assignee_ids,\n                            'label_ids', label_ids\n                    );\n                    \n                    -- Create previous attributes with only the previous label IDs\n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue_label',\n                            NEW.issue_id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object('data', enriched_data, 'previous_attributes', jsonb_build_object('label_ids', previous_label_ids)),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue_label %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ", hash='cd5185ba9195ed9cd397a261a42ea3233d6cab08', operation='INSERT', pgid='pgtrigger_issue_label_outbox_insert_a8b0d', table='issue_labels', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issuelabelproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_label_outbox_update', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    event_type_name TEXT;\n                    enriched_data JSONB;\n                    assignee_ids JSONB;\n                    current_label_ids JSONB;\n                    previous_label_ids JSONB;\n                    issue_data JSONB;\n                BEGIN\n                    -- Only trigger on soft delete (deleted_at changing from NULL to NOT NULL)\n                    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                        -- Determine event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'workitem.label.removed'\n                                WHEN it.is_epic = true THEN 'epic.label.removed'\n                                ELSE 'workitem.label.removed'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- If no issue found, default to 'workitem.label.removed'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'workitem.label.removed';\n                        END IF;\n                        \n                        -- Get the complete issue data (excluding description fields)\n                        SELECT to_jsonb(i) - 'description_html' - 'description_binary' - 'description' - 'description_stripped'\n                        INTO issue_data\n                        FROM issues i\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- Fetch assignee IDs\n                        SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                        INTO assignee_ids\n                        FROM issue_assignees ia\n                        WHERE ia.issue_id = OLD.issue_id AND ia.deleted_at IS NULL;\n                        \n                        -- Fetch current label IDs (excluding the one being removed)\n                        SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                        INTO current_label_ids\n                        FROM issue_labels il\n                        WHERE il.issue_id = OLD.issue_id AND il.deleted_at IS NULL AND il.id != OLD.id;\n                        \n                        -- Fetch ALL label IDs (including the one being removed) for previous_attributes\n                        SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                        INTO previous_label_ids\n                        FROM issue_labels il\n                        WHERE il.issue_id = OLD.issue_id AND il.deleted_at IS NULL;\n                        \n                        -- Create enriched data with complete issue, assignee IDs, and current label IDs (after removal)\n                        enriched_data := issue_data || jsonb_build_object(\n                            'assignee_ids', assignee_ids,\n                            'label_ids', current_label_ids\n                        );\n                        \n                        -- Create previous attributes with only the previous label IDs (including the removed one)\n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue_label',\n                                OLD.issue_id,\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                jsonb_build_object('data', enriched_data, 'previous_attributes', jsonb_build_object('label_ids', previous_label_ids)),\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox delete-event failed for issue_label %, reason: %',\n                                         OLD.issue_id, SQLERRM;\n                        END;\n                    END IF;\n                    RETURN NEW;\n                END;\n                ", hash='c0b11230ab208f9235feacbb2f7b9ce71b7614eb', operation='UPDATE', pgid='pgtrigger_issue_label_outbox_update_47e56', table='issue_labels', when='BEFORE')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issuelinkproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_link_outbox_insert', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    event_type_name TEXT;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'workitem.link.added'\n                            WHEN it.is_epic = true THEN 'epic.link.added'\n                            ELSE 'workitem.link.added'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'workitem.link.added'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'workitem.link.added';\n                    END IF;\n                    \n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue_link',\n                            NEW.issue_id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', '{}'),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue_link %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ", hash='87a85f0b72f21754e3ff166ffcd6ec2f74328897', operation='INSERT', pgid='pgtrigger_issue_link_outbox_insert_38eb1', table='issue_links', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issuelinkproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_link_outbox_update', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    changes JSONB := '{}';\n                    field_name TEXT;\n                    old_value TEXT;\n                    new_value TEXT;\n                    event_type_name TEXT;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'workitem.link.updated'\n                            WHEN it.is_epic = true THEN 'epic.link.updated'\n                            ELSE 'workitem.link.updated'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'workitem.link.updated'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'workitem.link.updated';\n                    END IF;\n                    \n                    -- Check if this is a soft delete (deleted_at changed from null to not null)\n                    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                        -- This is a soft delete\n                        -- Determine delete event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'workitem.link.removed'\n                                WHEN it.is_epic = true THEN 'epic.link.removed'\n                                ELSE 'workitem.link.removed'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- If no issue found, default to 'workitem.link.removed'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'workitem.link.removed';\n                        END IF;\n                        \n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue',\n                                OLD.issue_id,\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                jsonb_build_object('data', '{}', 'previous_attributes', row_to_json(OLD)),\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox delete failed for issue %, reason: %',\n                                             OLD.id, SQLERRM;\n                        END;\n                    ELSE\n                        -- This is a regular update, check for changes\n                        -- Loop through all columns to detect changes\n                        FOR field_name IN \n                            SELECT column_name \n                            FROM information_schema.columns \n                            WHERE table_name = 'issue_links' \n                            AND table_schema = 'public'\n                            AND column_name != 'updated_at'  -- Skip updated_at column\n                        LOOP\n                            -- Get old and new values as text to avoid JSON conversion issues\n                            EXECUTE format('SELECT ($1).%I::text, ($2).%I::text', field_name, field_name) \n                            INTO old_value, new_value \n                            USING OLD, NEW;\n                            \n                            -- If values are different, add to changes\n                            IF old_value IS DISTINCT FROM new_value THEN\n                                changes := changes || jsonb_build_object(\n                                    field_name, \n                                    old_value\n                                );\n                            END IF;\n                        END LOOP;\n                        \n                        -- Only insert if there are actual changes\n                        IF jsonb_typeof(changes) = 'object' AND changes != '{}' THEN\n                            BEGIN\n                                INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                VALUES (\n                                    gen_random_uuid(),\n                                    event_type_name, \n                                    'issue',\n                                    NEW.issue_id,\n                                    NEW.workspace_id,\n                                    NEW.project_id,\n                                    jsonb_build_object(\n                                        'data', row_to_json(NEW),\n                                        'previous_attributes', changes\n                                    ),\n                                    now(),\n                                    NEW.updated_by_id,\n                                    COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                )\n                                ON CONFLICT DO NOTHING;\n                            EXCEPTION\n                                WHEN others THEN\n                                    RAISE WARNING 'Outbox update failed for issue %, reason: %',\n                                                 NEW.id, SQLERRM;\n                            END;\n                        END IF;\n                    END IF;\n                    \n                    RETURN NEW;\n                END;\n                ", hash='986b7047f2f9f837aa953626301985006bd9512e', operation='UPDATE', pgid='pgtrigger_issue_link_outbox_update_0b646', table='issue_links', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issueproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_outbox_insert', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    event_type_name TEXT;\n                    filtered_new_data JSONB;\n                    assignee_ids JSONB;\n                    label_ids JSONB;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN NEW.type_id IS NULL THEN 'workitem.created'\n                            WHEN it.is_epic = true THEN 'epic.created'\n                            ELSE 'workitem.created'\n                        END\n                    INTO event_type_name\n                    FROM issue_types it\n                    WHERE it.id = NEW.type_id;\n                    \n                    -- If no issue type found, default to 'workitem.created'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'workitem.created';\n                    END IF;\n                    \n                    -- Fetch assignee IDs\n                    SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                    INTO assignee_ids\n                    FROM issue_assignees ia\n                    WHERE ia.issue_id = NEW.id AND ia.deleted_at IS NULL;\n                    \n                    -- Fetch label IDs\n                    SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                    INTO label_ids\n                    FROM issue_labels il\n                    WHERE il.issue_id = NEW.id AND il.deleted_at IS NULL;\n                    \n                    -- Create filtered NEW data excluding description fields\n                    filtered_new_data := to_jsonb(NEW) - 'description_html' - 'description_binary' - 'description' - 'description_stripped';\n                    \n                    -- Add assignee and label IDs to the data\n                    filtered_new_data := filtered_new_data || jsonb_build_object(\n                        'assignee_ids', assignee_ids,\n                        'label_ids', label_ids\n                    );\n                    \n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue',\n                            NEW.id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object(\n                                'data', filtered_new_data,\n                                'previous_attributes', '{}'\n                            ),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue %, reason: %',\n                                         NEW.id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ", hash='4ee5ed614f7e196ac61b756b6b7486f8019f9ae7', operation='INSERT', pgid='pgtrigger_issue_outbox_insert_0de30', table='issues', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issueproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_outbox_update', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    changes JSONB := '{}';\n                    field_name TEXT;\n                    old_value TEXT;\n                    new_value TEXT;\n                    event_type_name TEXT;\n                    old_is_epic BOOLEAN := false;\n                    new_is_epic BOOLEAN := false;\n                    conversion_event_name TEXT;\n                    filtered_new_data JSONB;\n                    filtered_old_data JSONB;\n                    assignee_ids JSONB;\n                    label_ids JSONB;\n                    has_non_description_changes BOOLEAN := false;\n                    state_changed BOOLEAN := false;\n                BEGIN\n                    -- Check if this is a soft delete (deleted_at changed from null to not null)\n                    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                        -- This is a soft delete\n                        -- Determine delete event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN OLD.type_id IS NULL THEN 'workitem.deleted'\n                                WHEN it.is_epic = true THEN 'epic.deleted'\n                                ELSE 'workitem.deleted'\n                            END\n                        INTO event_type_name\n                        FROM issue_types it\n                        WHERE it.id = OLD.type_id;\n                        \n                        -- If no issue type found, default to 'workitem.deleted'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'workitem.deleted';\n                        END IF;\n                        \n                        -- Create filtered OLD data excluding description fields\n                        filtered_old_data := to_jsonb(OLD) - 'description_html' - 'description_binary' - 'description' - 'description_stripped';\n                        \n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue',\n                                OLD.id,\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                jsonb_build_object('data', '{}', 'previous_attributes', filtered_old_data),\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox delete failed for issue %, reason: %',\n                                             OLD.id, SQLERRM;\n                        END;\n                    ELSE\n                        -- This is a regular update, check for changes excluding description fields\n                        -- First, check if there are any non-description field changes\n                        FOR field_name IN \n                            SELECT column_name \n                            FROM information_schema.columns \n                            WHERE table_name = 'issues' \n                            AND table_schema = 'public'\n                            AND column_name NOT IN ('updated_at', 'updated_by_id', 'description_html', 'description_binary', 'description', 'description_stripped')  -- Skip description fields\n                        LOOP\n                            -- Get old and new values as text to avoid JSON conversion issues\n                            EXECUTE format('SELECT ($1).%I::text, ($2).%I::text', field_name, field_name) \n                            INTO old_value, new_value \n                            USING OLD, NEW;\n                            \n                            -- If values are different, add to changes and mark that we have non-description changes\n                            IF old_value IS DISTINCT FROM new_value THEN\n                                has_non_description_changes := true;\n                                changes := changes || jsonb_build_object(\n                                    field_name, \n                                    old_value\n                                );\n                                \n                                -- Check if state field has changed\n                                IF field_name = 'state_id' THEN\n                                    state_changed := true;\n                                END IF;\n                            END IF;\n                        END LOOP;\n                        \n                        -- Only proceed if there are non-description field changes\n                        IF has_non_description_changes THEN\n                            -- Determine event type based on issue type and whether state changed\n                            IF state_changed THEN\n                                -- State has changed, use state-specific event types\n                                SELECT \n                                    CASE \n                                        WHEN NEW.type_id IS NULL THEN 'workitem.state.updated'\n                                        WHEN it.is_epic = true THEN 'epic.state.updated'\n                                        ELSE 'workitem.state.updated'\n                                    END\n                                INTO event_type_name\n                                FROM issue_types it\n                                WHERE it.id = NEW.type_id;\n                                \n                                -- If no issue type found, default to 'workitem.state.updated'\n                                IF event_type_name IS NULL THEN\n                                    event_type_name := 'workitem.state.updated';\n                                END IF;\n                            ELSE\n                                -- Regular update, use generic event types\n                                SELECT \n                                    CASE \n                                        WHEN NEW.type_id IS NULL THEN 'workitem.updated'\n                                        WHEN it.is_epic = true THEN 'epic.updated'\n                                        ELSE 'workitem.updated'\n                                    END\n                                INTO event_type_name\n                                FROM issue_types it\n                                WHERE it.id = NEW.type_id;\n                                \n                                -- If no issue type found, default to 'workitem.updated'\n                                IF event_type_name IS NULL THEN\n                                    event_type_name := 'workitem.updated';\n                                END IF;\n                            END IF;\n                            \n                            -- Fetch assignee IDs\n                            SELECT COALESCE(jsonb_agg(ia.assignee_id ORDER BY ia.created_at), '[]'::jsonb)\n                            INTO assignee_ids\n                            FROM issue_assignees ia\n                            WHERE ia.issue_id = NEW.id AND ia.deleted_at IS NULL;\n                            \n                            -- Fetch label IDs\n                            SELECT COALESCE(jsonb_agg(il.label_id ORDER BY il.created_at), '[]'::jsonb)\n                            INTO label_ids\n                            FROM issue_labels il\n                            WHERE il.issue_id = NEW.id AND il.deleted_at IS NULL;\n                            \n                            -- Create filtered NEW data excluding description fields\n                            filtered_new_data := to_jsonb(NEW) - 'description_html' - 'description_binary' - 'description' - 'description_stripped';\n                            \n                            -- Add assignee and label IDs to the data\n                            filtered_new_data := filtered_new_data || jsonb_build_object(\n                                'assignee_ids', assignee_ids,\n                                'label_ids', label_ids\n                            );\n                            \n                            BEGIN\n                                INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                VALUES (\n                                    gen_random_uuid(),\n                                    event_type_name, \n                                    'issue',\n                                    NEW.id,\n                                    NEW.workspace_id,\n                                    NEW.project_id,\n                                    jsonb_build_object(\n                                        'data', filtered_new_data,\n                                        'previous_attributes', changes\n                                    ),\n                                    now(),\n                                    NEW.updated_by_id,\n                                    COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                )\n                                ON CONFLICT DO NOTHING;\n                            EXCEPTION\n                                WHEN others THEN\n                                    RAISE WARNING 'Outbox update failed for issue %, reason: %',\n                                                 NEW.id, SQLERRM;\n                            END;\n                        END IF;\n                        \n                        -- Check if type_id has changed to trigger conversion events (only if there are other changes)\n                        IF has_non_description_changes AND OLD.type_id IS DISTINCT FROM NEW.type_id THEN\n                            -- Determine if old type was epic\n                            IF OLD.type_id IS NOT NULL THEN\n                                SELECT COALESCE(it.is_epic, false) INTO old_is_epic\n                                FROM issue_types it\n                                WHERE it.id = OLD.type_id;\n                            END IF;\n                            \n                            -- Determine if new type is epic\n                            IF NEW.type_id IS NOT NULL THEN\n                                SELECT COALESCE(it.is_epic, false) INTO new_is_epic\n                                FROM issue_types it\n                                WHERE it.id = NEW.type_id;\n                            END IF;\n                            \n                            -- Determine conversion event name\n                            IF old_is_epic = false AND new_is_epic = true THEN\n                                conversion_event_name := 'workitem.converted.to_epic';\n                            ELSIF old_is_epic = true AND new_is_epic = false THEN\n                                conversion_event_name := 'epic.converted.to_workitem';\n                            END IF;\n                            \n                            -- Insert conversion event if applicable\n                            IF conversion_event_name IS NOT NULL THEN\n                                -- Create filtered NEW data excluding description fields for conversion event\n                                filtered_new_data := to_jsonb(NEW) - 'description_html' - 'description_binary' - 'description' - 'description_stripped';\n                                \n                                -- Add assignee and label IDs to the conversion data\n                                filtered_new_data := filtered_new_data || jsonb_build_object(\n                                    'assignee_ids', assignee_ids,\n                                    'label_ids', label_ids\n                                );\n                                \n                                BEGIN\n                                    INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                    VALUES (\n                                        gen_random_uuid(),\n                                        conversion_event_name,\n                                        'issue',\n                                        NEW.id,\n                                        NEW.workspace_id,\n                                        NEW.project_id,\n                                        jsonb_build_object(\n                                            'data', filtered_new_data,\n                                            'previous_attributes', jsonb_build_object('type_id', OLD.type_id)\n                                        ),\n                                        now(),\n                                        NEW.updated_by_id,\n                                        COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                    )\n                                    ON CONFLICT DO NOTHING;\n                                EXCEPTION\n                                    WHEN others THEN\n                                        RAISE WARNING 'Outbox conversion failed for issue %, reason: %',\n                                                     NEW.id, SQLERRM;\n                                END;\n                            END IF;\n                        END IF;\n                    END IF;\n                    \n                    RETURN NEW;\n                END;\n                ", hash='10447c94aaf15aa9fc99874ac90654c27bbf32a3', operation='UPDATE', pgid='pgtrigger_issue_outbox_update_b23e9', table='issues', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issuerelationproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_relation_outbox_insert', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    event_type_name TEXT;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'workitem.relation.added'\n                            WHEN it.is_epic = true THEN 'epic.relation.added'\n                            ELSE 'workitem.relation.added'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'workitem.relation.added'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'workitem.relation.added';\n                    END IF;\n                    \n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            event_type_name,\n                            'issue_relation',\n                            NEW.issue_id,\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', '{}'),\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for issue_relation %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ", hash='99c2794720b672da310b60e3c9628bedee918093', operation='INSERT', pgid='pgtrigger_issue_relation_outbox_insert_29038', table='issue_relations', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='issuerelationproxy',
            trigger=pgtrigger.compiler.Trigger(name='issue_relation_outbox_update', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                DECLARE\n                    changes JSONB := '{}';\n                    field_name TEXT;\n                    old_value TEXT;\n                    new_value TEXT;\n                    event_type_name TEXT;\n                BEGIN\n                    -- Determine event type based on issue type\n                    SELECT \n                        CASE \n                            WHEN i.type_id IS NULL THEN 'workitem.relation.updated'\n                            WHEN it.is_epic = true THEN 'epic.relation.updated'\n                            ELSE 'workitem.relation.updated'\n                        END\n                    INTO event_type_name\n                    FROM issues i\n                    LEFT JOIN issue_types it ON it.id = i.type_id\n                    WHERE i.id = NEW.issue_id;\n                    \n                    -- If no issue found, default to 'workitem.relation.updated'\n                    IF event_type_name IS NULL THEN\n                        event_type_name := 'workitem.relation.updated';\n                    END IF;\n                    \n                    -- Check if this is a soft delete (deleted_at changed from null to not null)\n                    IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                        -- This is a soft delete\n                        -- Determine delete event type based on issue type\n                        SELECT \n                            CASE \n                                WHEN i.type_id IS NULL THEN 'workitem.relation.removed'\n                                WHEN it.is_epic = true THEN 'epic.relation.removed'\n                                ELSE 'workitem.relation.removed'\n                            END\n                        INTO event_type_name\n                        FROM issues i\n                        LEFT JOIN issue_types it ON it.id = i.type_id\n                        WHERE i.id = OLD.issue_id;\n                        \n                        -- If no issue found, default to 'workitem.relation.removed'\n                        IF event_type_name IS NULL THEN\n                            event_type_name := 'workitem.relation.removed';\n                        END IF;\n                        \n                        BEGIN\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                event_type_name,\n                                'issue',\n                                OLD.issue_id,\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                jsonb_build_object('data', '{}', 'previous_attributes', row_to_json(OLD)),\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        EXCEPTION\n                            WHEN others THEN\n                                RAISE WARNING 'Outbox delete failed for issue_relation %, reason: %',\n                                             OLD.issue_id, SQLERRM;\n                        END;\n                    ELSE\n                        -- This is a regular update, check for changes\n                        -- Loop through all columns to detect changes\n                        FOR field_name IN \n                            SELECT column_name \n                            FROM information_schema.columns \n                            WHERE table_name = 'issue_relations' \n                            AND table_schema = 'public'\n                            AND column_name != 'updated_at'  -- Skip updated_at column\n                        LOOP\n                            -- Get old and new values as text to avoid JSON conversion issues\n                            EXECUTE format('SELECT ($1).%I::text, ($2).%I::text', field_name, field_name) \n                            INTO old_value, new_value \n                            USING OLD, NEW;\n                            \n                            -- If values are different, add to changes\n                            IF old_value IS DISTINCT FROM new_value THEN\n                                changes := changes || jsonb_build_object(\n                                    field_name, \n                                    old_value\n                                );\n                            END IF;\n                        END LOOP;\n                        \n                        -- Only insert if there are actual changes\n                        IF jsonb_typeof(changes) = 'object' AND changes != '{}' THEN\n                            BEGIN\n                                INSERT INTO outbox (event_id, event_type, entity_type, entity_id, workspace_id, project_id, payload, created_at, initiator_id, initiator_type)\n                                VALUES (\n                                    gen_random_uuid(),\n                                    event_type_name, \n                                    'issue',\n                                    NEW.issue_id,\n                                    NEW.workspace_id,\n                                    NEW.project_id,\n                                    jsonb_build_object(\n                                        'data', row_to_json(NEW),\n                                        'previous_attributes', changes\n                                    ),\n                                    now(),\n                                    NEW.updated_by_id,\n                                    COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                                )\n                                ON CONFLICT DO NOTHING;\n                            EXCEPTION\n                                WHEN others THEN\n                                    RAISE WARNING 'Outbox update failed for issue_relation %, reason: %',\n                                                 NEW.issue_id, SQLERRM;\n                            END;\n                        END IF;\n                    END IF;\n                    RETURN NEW;\n                END;\n                ", hash='2226563b19d4bac5219244635755be20bcb3fce7', operation='UPDATE', pgid='pgtrigger_issue_relation_outbox_update_0c350', table='issue_relations', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='moduleissueproxy',
            trigger=pgtrigger.compiler.Trigger(name='module_issue_outbox_insert', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                BEGIN\n                    BEGIN\n                        INSERT INTO outbox (event_id, event_type, entity_type, entity_id, payload, workspace_id, project_id, created_at, initiator_id, initiator_type)\n                        VALUES (\n                            gen_random_uuid(),\n                            'workitem.module.added',\n                            'module_issue',\n                            NEW.issue_id,\n                            jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', '{}'),\n                            NEW.workspace_id,\n                            NEW.project_id,\n                            now(),\n                            NEW.created_by_id,\n                            COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                        )\n                        ON CONFLICT DO NOTHING;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox insert failed for module_issue %, reason: %',\n                                         NEW.issue_id, SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ", hash='daaca50dd151a01e81781f0f1b10e1bf5ad3948d', operation='INSERT', pgid='pgtrigger_module_issue_outbox_insert_4a4e3', table='module_issues', when='AFTER')),
        ),
        pgtrigger.migrations.AddTrigger(
            model_name='moduleissueproxy',
            trigger=pgtrigger.compiler.Trigger(name='module_issue_outbox_update', sql=pgtrigger.compiler.UpsertTriggerSql(func="\n                BEGIN\n                    BEGIN\n                        -- Check if this is a soft delete (deleted_at changed from null to not null)\n                        IF OLD.deleted_at IS NULL AND NEW.deleted_at IS NOT NULL THEN\n                            -- This is a soft delete\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, payload, workspace_id, project_id, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                'workitem.module.removed',\n                                'module_issue',\n                                OLD.issue_id,\n                                jsonb_build_object('data', '{}', 'previous_attributes', row_to_json(OLD)),\n                                OLD.workspace_id,\n                                OLD.project_id,\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        ELSE\n                            -- This is a regular update\n                            INSERT INTO outbox (event_id, event_type, entity_type, entity_id, payload, workspace_id, project_id, created_at, initiator_id, initiator_type)\n                            VALUES (\n                                gen_random_uuid(),\n                                'workitem.module.moved',\n                                'module_issue',\n                                NEW.issue_id,\n                                jsonb_build_object('data', row_to_json(NEW), 'previous_attributes', row_to_json(OLD)),\n                                NEW.workspace_id,\n                                NEW.project_id,\n                                now(),\n                                NEW.updated_by_id,\n                                COALESCE(current_setting('plane.initiator_type', true), 'USER')\n                            )\n                            ON CONFLICT DO NOTHING;\n                        END IF;\n                    EXCEPTION\n                        WHEN others THEN\n                            RAISE WARNING 'Outbox update-event failed for module_issue %, reason: %',\n                                         COALESCE(NEW.issue_id, OLD.issue_id), SQLERRM;\n                    END;\n                    RETURN NEW;\n                END;\n                ", hash='331c111525274cebdb8d98ca9ce322dd258ee1a8', operation='UPDATE', pgid='pgtrigger_module_issue_outbox_update_9f191', table='module_issues', when='AFTER')),
        ),
    ]
