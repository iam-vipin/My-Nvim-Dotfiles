# SPDX-FileCopyrightText: 2023-present Plane Software, Inc.
# SPDX-License-Identifier: LicenseRef-Plane-Commercial
#
# Licensed under the Plane Commercial License (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# https://plane.so/legals/eula
#
# DO NOT remove or modify this notice.
# NOTICE: Proprietary and confidential. Unauthorized use or distribution is prohibited.

"""Action artifacts endpoint for managing AI-planned action results."""

from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from uuid import UUID

from fastapi import APIRouter
from fastapi import Depends
from fastapi import HTTPException
from fastapi import Path
from fastapi import Query
from fastapi.responses import JSONResponse
from pydantic import UUID4
from sqlmodel.ext.asyncio.session import AsyncSession

from pi import logger
from pi.app.api.dependencies import get_current_user
from pi.app.schemas.artifact import ArtifactUpdateRequest
from pi.app.schemas.artifact import ArtifactUpdateResponse
from pi.core.db.plane_pi.lifecycle import get_async_session
from pi.services.actions.artifacts.utils import batch_prepare_artifact_response_data
from pi.services.actions.prompt_followup import handle_artifact_prompt_followup
from pi.services.retrievers.pg_store.action_artifact import get_action_artifacts_by_chat_id
from pi.services.retrievers.pg_store.action_artifact import get_action_artifacts_by_ids

log = logger.getChild("v2.artifacts")
router = APIRouter()


@router.get("/")
async def list_artifacts(
    ids: Optional[List[UUID4]] = Query(None, description="List of artifact UUIDs to retrieve"),
    chat_id: Optional[UUID4] = Query(None, description="Filter artifacts by chat UUID"),
    current_user=Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    List action artifacts with optional filtering.

    This endpoint retrieves action artifacts generated by AI during action planning
    and execution. Artifacts represent planned or executed actions (like creating
    issues, updating projects, etc.) and their current state.

    Artifacts can be filtered by:
    - Specific artifact IDs (batch retrieval)
    - Chat ID (all artifacts in a conversation)

    If no filters are provided, returns an error (to prevent accidentally loading
    all artifacts).

    Args:
        ids: Optional list of artifact UUIDs for batch retrieval
        chat_id: Optional chat UUID to get all artifacts in that chat
        session: Session cookie for authentication (injected)
        db: Database session (injected)

    Returns:
        JSON response with:
        - success: Boolean indicating operation success
        - artifacts: List of artifact objects containing:
            - id: Artifact UUID
            - artifact_data: Planned/executed action data
            - status: Current status (planned, executed, failed)
            - is_editable: Whether artifact can be modified
            - message_id: Associated message UUID
            - chat_id: Associated chat UUID
            - entity_type: Type of entity (issue, project, etc.)
            - entity_id: ID of created/updated entity (if executed)

    Status Codes:
        - 200: Artifacts retrieved successfully
        - 400: No filter provided (ids or chat_id required)
        - 401: Invalid or missing authentication
        - 500: Internal server error

    Example Request (by IDs):
        GET /api/v2/artifacts/?ids=abc-123&ids=def-456

    Example Request (by chat):
        GET /api/v2/artifacts/?chat_id=xyz-789

    Example Response:
        {
            "success": true,
            "artifacts": [
                {
                    "id": "abc-123",
                    "artifact_data": {
                        "action": "create_issue",
                        "title": "Fix login bug",
                        "description": "..."
                    },
                    "status": "executed",
                    "is_editable": true,
                    "message_id": "msg-001",
                    "chat_id": "chat-001",
                    "entity_type": "issue",
                    "entity_id": "issue-123"
                }
            ]
        }

    Notes:
        - Artifacts from the latest message in a chat are editable
        - Only user's own artifacts are returned
        - Artifacts include execution status and results
        - At least one filter (ids or chat_id) must be provided
        - Deprecated V1 endpoints:
            - GET /api/v1/artifacts/ (with artifact_ids query param)
            - GET /api/v1/artifacts/chat/{chat_id}/

    Use Cases:
        - Load artifacts for specific messages
        - Display all actions planned in a conversation
        - Check execution status of batch actions
        - Retrieve entity IDs created by actions
    """
    try:
        pass
    except Exception as e:
        log.error(f"Error validating session: {e!s}")
        return JSONResponse(
            status_code=401,
            content={"success": False, "detail": "Invalid Session"},
        )

    try:
        # Require at least one filter to prevent loading all artifacts
        if not ids and not chat_id:
            return JSONResponse(
                status_code=400,
                content={
                    "success": False,
                    "detail": "At least one filter required: 'ids' or 'chat_id'",
                },
            )

        # Get artifacts by IDs
        if ids:
            artifacts = await get_action_artifacts_by_ids(db, ids)

            # Group artifacts by chat_id to find latest in each chat
            artifacts_by_chat: Dict[Any, Any] = {}
            for artifact in artifacts:
                chat_id_str = str(artifact.chat_id)
                if chat_id_str not in artifacts_by_chat:
                    artifacts_by_chat[chat_id_str] = []
                artifacts_by_chat[chat_id_str].append(artifact)

            # Find actual latest message_id in each chat (batch query for performance)
            from pi.services.retrievers.pg_store.message import get_latest_message_ids_for_chats

            chat_uuids = [UUID(chat_id_str) for chat_id_str in artifacts_by_chat.keys()]
            latest_message_ids = await get_latest_message_ids_for_chats(db, chat_uuids)

            # Use batch preparation
            artifacts_data = await batch_prepare_artifact_response_data(db, artifacts, latest_message_ids)

            return JSONResponse(
                status_code=200,
                content={"success": True, "artifacts": artifacts_data},
            )

        # Get artifacts by chat_id
        elif chat_id:
            artifacts = await get_action_artifacts_by_chat_id(db, chat_id)

            # Find the actual latest message_id in the chat
            from pi.services.retrievers.pg_store.message import get_latest_message_id_for_chat

            latest_message_id = await get_latest_message_id_for_chat(db, chat_id)

            # Create latest_message_ids dict for batch processing
            latest_message_ids = {str(chat_id): latest_message_id}

            # Use batch preparation
            artifacts_data = await batch_prepare_artifact_response_data(db, artifacts, latest_message_ids)

            return JSONResponse(
                status_code=200,
                content={"success": True, "artifacts": artifacts_data},
            )

    except HTTPException:
        raise
    except Exception as e:
        log.error(f"List artifacts failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/{artifact_id}/followup", response_model=ArtifactUpdateResponse)
async def create_artifact_followup(
    request: ArtifactUpdateRequest,
    artifact_id: UUID4 = Path(..., description="UUID of the artifact to update"),
    current_user=Depends(get_current_user),
    db: AsyncSession = Depends(get_async_session),
):
    """
    Create a followup prompt to update an artifact.

    This endpoint allows users to refine or modify AI-planned actions through
    natural language prompts. When an artifact contains a planned action that
    needs adjustment (e.g., changing issue title, adding more details), users
    can provide a followup prompt to regenerate the artifact with modifications.

    The followup process:
    1. Retrieves the current artifact and its data
    2. Processes the user's refinement prompt
    3. Regenerates the artifact with AI
    4. Updates the artifact with new data
    5. Returns the updated artifact

    Common use cases:
    - "Add more details to the description"
    - "Change the priority to high"
    - "Include these additional labels: bug, urgent"
    - "Make the title more specific"

    Args:
        artifact_id: UUID of the artifact to update (path parameter)
        request: ArtifactUpdateRequest containing:
            - query: Natural language refinement prompt
            - workspace_id: UUID of workspace
            - chat_id: UUID of chat
            - artifact_id: UUID of artifact (redundant with path param)
            - project_id: Optional project UUID
            - entity_type: Type of entity being created/updated
            - current_artifact_data: Current artifact data
            - user_message_id: Associated user message UUID
        session: Session cookie for authentication (injected)
        db: Database session (injected)

    Returns:
        ArtifactUpdateResponse with:
        - success: Boolean indicating operation success
        - artifact: Updated artifact object
        - message: Status message

    Status Codes:
        - 200: Artifact updated successfully
        - 401: Invalid or missing authentication
        - 422: Unprocessable entity (business logic error)
        - 500: Internal server error

    Example Request:
        POST /api/v2/artifacts/abc-123/followup
        {
            "query": "Add a note about testing on staging first",
            "workspace_id": "workspace-001",
            "chat_id": "chat-001",
            "artifact_id": "abc-123",
            "entity_type": "issue",
            "current_artifact_data": {
                "action": "create_issue",
                "title": "Deploy new feature",
                "description": "Deploy feature X to production"
            },
            "user_message_id": "msg-001"
        }

    Example Response:
        {
            "success": true,
            "artifact": {
                "id": "abc-123",
                "artifact_data": {
                    "action": "create_issue",
                    "title": "Deploy new feature",
                    "description": "Deploy feature X to production\n\nNote: Test on staging first before production deployment"
                },
                "status": "planned",
                "is_editable": true
            },
            "message": "Artifact updated successfully"
        }

    Notes:
        - Only artifacts from the latest message are editable
        - The AI preserves the original intent while applying refinements
        - Users can iterate multiple times on the same artifact
        - Each followup creates a new message in the conversation
        - The artifact_id in path takes precedence over body
        - Deprecated V1 endpoint: POST /api/v1/artifacts/{artifact_id}/followup/

    Use Cases:
        - Refining issue descriptions before creation
        - Adding missing details to planned actions
        - Adjusting priorities or labels
        - Clarifying requirements
        - Iterative action planning
    """
    try:
        # Validate session
        user_id = current_user.id

        # Use artifact_id from path parameter (takes precedence)
        result = await handle_artifact_prompt_followup(
            db=db,
            artifact_id=artifact_id,  # Use path parameter
            current_query=request.query,
            workspace_id=request.workspace_id,
            chat_id=request.chat_id,
            user_id=str(user_id),
            project_id=request.project_id,
            entity_type=request.entity_type,
            current_artifact_data=request.current_artifact_data,
            user_message_id=request.user_message_id,
        )

        # Check if the operation was successful and return appropriate status code
        if result.get("success", False):
            return JSONResponse(status_code=200, content=result)
        else:
            # If success=False, return 422 (Unprocessable Entity) for business logic errors
            return JSONResponse(status_code=422, content=result)

    except HTTPException:
        # Re-raise HTTP exceptions (like 401) as-is
        raise
    except Exception as e:
        log.error(f"Artifact followup failed: {str(e)}")
        # Return 500 for unexpected server errors
        raise HTTPException(status_code=500, detail=str(e))
