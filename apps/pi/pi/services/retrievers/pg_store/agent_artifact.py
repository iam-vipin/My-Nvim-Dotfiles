from typing import Any
from typing import Dict
from typing import Optional
from uuid import UUID

from pydantic import UUID4
from sqlalchemy import desc
from sqlalchemy import func
from sqlalchemy import select
from sqlmodel.ext.asyncio.session import AsyncSession

from pi import logger
from pi.app.models import AgentArtifact
from pi.app.models.enums import AgentArtifactContentType
from pi.app.models.enums import AgentsType

log = logger.getChild(__name__)


async def upsert_agent_artifact(
    db: AsyncSession,
    agent_name: AgentsType,
    workspace_id: Optional[UUID4],
    project_id: Optional[UUID4],
    issue_id: Optional[UUID4],
    content: str,
    content_type: AgentArtifactContentType,
) -> Dict[str, Any]:
    """
    Creates a new agent artifact record, calculating the next version number.

    Returns:
        A dictionary with operation status and the artifact object or error details.
    """
    try:
        # 1. Determine the next version number for this agent and issue
        latest_version_query = (
            select(func.max(AgentArtifact.version)).where(AgentArtifact.agent_name == agent_name).where(AgentArtifact.issue_id == issue_id)  # type: ignore[var-annotated,arg-type]
        )
        result = await db.execute(latest_version_query)
        latest_version = result.scalar() or 0
        next_version = latest_version + 1

        # 2. Create the new artifact record
        new_artifact = AgentArtifact(
            agent_name=agent_name,
            workspace_id=workspace_id or None,
            project_id=project_id or None,
            issue_id=issue_id or None,
            content=content,
            content_type=content_type,
            version=next_version,
        )

        # 3. Add and commit
        db.add(new_artifact)
        await db.commit()
        await db.refresh(new_artifact)
        return {"message": "success", "artifact": new_artifact}

    except Exception as e:
        await db.rollback()
        log.error(f"Database upsert_agent_artifact failed for agent {agent_name} on issue {issue_id}: {str(e)}")
        return {"message": "error", "error": str(e)}


async def get_latest_agent_artifact(
    db: AsyncSession,
    agent_name: AgentsType,
    issue_id: UUID,
) -> Optional[AgentArtifact]:
    """
    Retrieves the most recent artifact generated by a specific agent for a specific issue.
    """
    try:
        stmt = (
            select(AgentArtifact)
            .where(AgentArtifact.agent_name == agent_name)  # type: ignore[arg-type]
            .where(AgentArtifact.issue_id == issue_id)  # type: ignore[arg-type]
            .order_by(desc(AgentArtifact.version))  # type: ignore[var-annotated,arg-type]
            .limit(1)
        )
        result = await db.execute(stmt)
        artifact = result.scalar_one_or_none()
        return artifact
    except Exception as e:
        log.error(f"Error retrieving latest artifact for agent {agent_name} on issue {issue_id}: {str(e)}")
        return None
