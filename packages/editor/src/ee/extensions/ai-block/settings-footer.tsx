/**
 * SPDX-FileCopyrightText: 2023-present Plane Software, Inc.
 * SPDX-License-Identifier: LicenseRef-Plane-Commercial
 *
 * Licensed under the Plane Commercial License (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * https://plane.so/legals/eula
 *
 * DO NOT remove or modify this notice.
 * NOTICE: Proprietary and confidential. Unauthorized use or distribution is prohibited.
 */

import { Button, getButtonStyling } from "@plane/propel/button";
import type { TAIBlockDetails, TAIBlockGenerateInputPartial, TAIBlockHandlers, TAIBlockType } from "@plane/types";
import { cn, renderFormattedDate } from "@plane/utils";
import { useMemo, useState } from "react";
import { EAIBlockAttributeNames } from "./types";
import type { TAIBlockAttributes } from "./types";
import type { Editor, NodeViewProps } from "@tiptap/react";
import { AIBlockFeedback } from "./feedback";
import { Tooltip } from "@plane/propel/tooltip";
import { Settings } from "lucide-react";
import { IconButton } from "@plane/propel/icon-button";
type CustomAIBlockSettingsFooterProps = {
  editor: Editor;
  node: NodeViewProps["node"] & {
    attrs: TAIBlockAttributes;
  };
  isEmpty: boolean;
  isDisabled: boolean;
  aiBlockHandlers: TAIBlockHandlers | undefined;
  selectedBlockType: TAIBlockType | undefined;
  block: Partial<TAIBlockDetails> | undefined;
  blockId: string | null;
  type: "settings" | "revision";
  getPos: () => number;
  updateAttributes: (attrs: Partial<TAIBlockAttributes>) => void;
  toggleSettings: () => void;
  saveDocument?: () => Promise<void>;
};

export const CustomAIBlockSettingsFooter = (props: CustomAIBlockSettingsFooterProps) => {
  const {
    editor,
    node,
    isEmpty,
    isDisabled,
    aiBlockHandlers,
    selectedBlockType,
    block,
    blockId,
    type,
    getPos,
    updateAttributes,
    toggleSettings,
    saveDocument,
  } = props;
  const [isSubmitting, setIsSubmitting] = useState(false);
  const editedAt = useMemo(() => renderFormattedDate((block?.updated_at || block?.created_at) ?? ""), [block]);

  const handleInsert = (content: string) => {
    const pos = getPos() + 1;
    const from = pos + 1; // Start of node content
    const to = pos + 1 + node.content.size; // End of node content
    editor
      .chain()
      .focus()
      .insertContentAt({ from, to }, content ?? "")
      .run();
  };
  const handleDelete = () => {
    const pos = getPos();
    editor
      .chain()
      .focus()
      .deleteRange({ from: pos, to: pos + node.nodeSize })
      .run();
  };
  const handleGenerate = async () => {
    if (!aiBlockHandlers || !selectedBlockType?.key) return;

    setIsSubmitting(true);
    try {
      let payload: TAIBlockGenerateInputPartial = {
        block_type: selectedBlockType?.key,
        content: selectedBlockType?.has_content ? (block?.content ?? "") : undefined,
      };

      if (blockId) {
        // Update existing block
        payload = { ...payload, block_id: blockId };
      }
      const response = await aiBlockHandlers.generateBlockContent(payload);
      if (response?.content) {
        handleInsert(response.content);
      }
      // Update node attributes with the response
      updateAttributes({
        [EAIBlockAttributeNames.ID]: response.block_id,
      });
    } catch (error) {
      console.error("Failed to save AI block:", error);
    } finally {
      setIsSubmitting(false);
    }
  };
  return (
    <div
      className={cn({
        "bg-layer-2 border-t border-subtle p-3 flex items-center justify-between gap-2": type === "settings",
        "hidden group-hover/ai-block-node:flex absolute bottom-1 right-0 bg-layer-2 shadow-raised-100 rounded-lg  p-1 items-center justify-end gap-3":
          type === "revision",
      })}
      contentEditable={false}
    >
      <div className="flex items-center gap-2">
        {!isEmpty && (
          <AIBlockFeedback feedback={block?.feedback} blockId={blockId} aiBlockHandlers={aiBlockHandlers} type={type} />
        )}
        {type === "revision" && (
          <Tooltip tooltipContent="Bad response" position="bottom" className="mb-4">
            <IconButton icon={Settings} onClick={() => toggleSettings()} variant="ghost" size="sm" />
          </Tooltip>
        )}
      </div>
      <div className="flex items-center gap-2">
        {type === "settings" && (
          <Button variant="ghost" size="base" onClick={handleDelete}>
            Discard
          </Button>
        )}
        {isEmpty ? (
          <Tooltip
            tooltipContent={`Generated by Plane AI ${editedAt ? `on ${editedAt}` : ""}`}
            position="bottom"
            className="mb-4"
          >
            <Button
              className={cn(getButtonStyling("primary", "base"))}
              onClick={() => void handleGenerate()}
              disabled={isSubmitting || isDisabled}
            >
              {isSubmitting ? "Generating" : "Generate"}
            </Button>
          </Tooltip>
        ) : (
          <Tooltip
            tooltipContent={`Generated by Plane AI ${editedAt ? `on ${editedAt}` : ""}`}
            position="bottom"
            className="mb-4"
          >
            <Button
              variant={type === "settings" ? "secondary" : "primary"}
              size="base"
              onClick={() => void handleGenerate()}
              disabled={isSubmitting}
            >
              {isSubmitting ? "Regenerating" : "Regenerate"}
            </Button>
          </Tooltip>
        )}
        {!isEmpty && type === "settings" && (
          <Button
            variant="primary"
            size="base"
            onClick={() => {
              void saveDocument?.();
              toggleSettings();
            }}
            disabled={isSubmitting}
          >
            Use this
          </Button>
        )}
      </div>
    </div>
  );
};
